#！/usr/bin/env python
# _*_ coding:utf-8 _*_

'''

@author: yerik

@contact: xiangzz159@qq.com

@time: 2018/9/27 16:32

@desc:

'''

# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.errors import OrderNotFound
from ccxt.bitmex import bitmex

class bitmex_testnet (bitmex):

    def describe(self):
        return self.deep_extend(super(bitmex_testnet, self).describe(), {
            'id': 'bitmex_testnet',
            'name': 'BitMEX TESTNET',
            'urls': {
                'test': 'https://testnet.bitmex.com',
                'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
                'api': 'https://testnet.bitmex.com',
                'www': 'https://testnet.bitmex.com',
                'doc': [
                    'https://testnet.bitmex.com/app/apiOverview',
                    'https://github.com/BitMEX/api-connectors/tree/master/official-http',
                ],
                'fees': 'https://testnet.bitmex.com/app/fees',
                'referral': 'https://testnet.bitmex.com/register/rm3C16',
            },
        })

    def fetch_position(self, symbol=None, params={}):
        self.load_markets()
        request = {}
        if symbol is not None:
            request['symbol'] = self.market_id(symbol)
        response = self.privateGetPosition(self.extend(request, params))
        return response

    def close_position(self, symbol, price=None, params={}):
        self.load_markets()
        request = {
            'symbol': self.market_id(symbol)
        }
        if price is not None:
            request['price'] = price
        response = self.privatePostOrderClosePosition(self.extend(request, params))
        order = self.parse_order(response)
        id = order['id']
        self.orders[id] = order
        return self.extend({'info': response}, order)

    def create_bulk_order(self, orders=[]):
        self.load_markets()
        results = []
        orders_ = []
        for order in orders:
            o = {
                'symbol': self.market_id(order['symbol']),
                'side': self.capitalize(order['side']),
                'orderQty': order['amount'],
                'ordType': self.capitalize(order['type'])
            }
            if 'price' in order:
                o['price'] = order['price']
            if order['type'] == 'stop':
                o['stopPx'] = order['stopPx']
            orders_.append(o)
        response = self.privatePostOrderBulk(self.extend({
            'orders': orders_
        }))
        for r in response:
            results.append(self.parse_order(r))
        return results


    def cancel_all_orders(self, symbol=None, side=None, params={}):
        self.load_markets()
        params = {}
        if symbol is not None:
            market = self.market(symbol)
            params['symbol'] = market['id']
        if side is not None:
            params['side'] = self.capitalize(side),
        response = self.privateDeleteOrderAll(self.extend(params, params))
        if len(response) > 0:
            order = response[0]
            error = self.safe_string(order, 'error')
            if error is not None:
                if error.find('Unable to cancel order due to existing state') >= 0:
                    raise OrderNotFound(self.id + ' cancelOrder() failed: ' + error)
            order = self.parse_order(order)
            self.orders[order['id']] = order
            return self.extend({'info': response}, order)
